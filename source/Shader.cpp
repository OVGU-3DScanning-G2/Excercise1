#include "../include/Shader.h"
#include <iostream>

/** @brief constructor of the shader class
    @details Internally it initializes OpenGL extensions.
*/
Shader::Shader()
{
  //get OpenGL Extension - Functions(incluide file "gl.h" does not known OpenGL functions > OpenGL 1.1)
  initializeOpenGLextensions();
}

/** @brief Initializes newer OpenGL-functions.
Imports the functionality by getting the function pointers from the opengl (graphics) driver
*/
void Shader::initializeOpenGLextensions()
{
#ifdef __linux__
    glCreateProgram = (PFNGLCREATEPROGRAMPROC)glXGetProcAddress((const GLubyte *)"glCreateProgram");
    glCreateShader = (PFNGLCREATESHADERPROC)glXGetProcAddress((const GLubyte *)"glCreateShader");
    glShaderSource = (PFNGLSHADERSOURCEPROC)glXGetProcAddress((const GLubyte *)"glShaderSource");
    glCompileShader = (PFNGLCOMPILESHADERPROC)glXGetProcAddress((const GLubyte *)"glCompileShader");
    glAttachShader = (PFNGLATTACHSHADERPROC)glXGetProcAddress((const GLubyte *)"glAttachShader");
    glLinkProgram = (PFNGLLINKPROGRAMPROC)glXGetProcAddress((const GLubyte *)"glLinkProgram");
    glUseProgram = (PFNGLUSEPROGRAMPROC)glXGetProcAddress((const GLubyte *)"glUseProgram");
    glGetShaderiv = (PFNGLGETSHADERIVPROC)glXGetProcAddress((const GLubyte *)"glGetShaderiv");
    glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)glXGetProcAddress((const GLubyte *)"glGetShaderInfoLog");
    glGetObjectParameterivARB = (PFNGLGETOBJECTPARAMETERIVARBPROC)glXGetProcAddress((const GLubyte *)"glGetObjectParameterivARB");
#else
    glCreateProgram = (PFNGLCREATEPROGRAMPROC)wglGetProcAddress("glCreateProgram");
    glCreateShader = (PFNGLCREATESHADERPROC)wglGetProcAddress("glCreateShader");
    glShaderSource = (PFNGLSHADERSOURCEPROC)wglGetProcAddress("glShaderSource");
    glCompileShader = (PFNGLCOMPILESHADERPROC)wglGetProcAddress("glCompileShader");
    glAttachShader = (PFNGLATTACHSHADERPROC)wglGetProcAddress("glAttachShader");
    glLinkProgram = (PFNGLLINKPROGRAMPROC)wglGetProcAddress("glLinkProgram");
    glUseProgram = (PFNGLUSEPROGRAMPROC)wglGetProcAddress("glUseProgram");
    glGetShaderiv = (PFNGLGETSHADERIVPROC)wglGetProcAddress("glGetShaderiv");
    glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)wglGetProcAddress("glGetShaderInfoLog");
    glGetObjectParameterivARB = (PFNGLGETOBJECTPARAMETERIVARBPROC)wglGetProcAddress("glGetObjectParameterivARB");
#endif
}

/** @brief Checks the compilation status of a shader.
    It also prints error/warning message that has been generated by the shader compiler.
    @return true if are no error or warning messages
*/
bool Shader::checkShaderCompilationStatus(GLhandleARB shaderObject) const
{
  GLint compiled;
  glGetObjectParameterivARB(shaderObject, GL_COMPILE_STATUS, &compiled);
  if (!compiled) {
    std::cout << "Vertex shader was not compiled!\n";
  }

  //Get error and warning messages from shader compilation
  GLint blen = 0;
  glGetShaderiv(shaderObject, GL_INFO_LOG_LENGTH, &blen);
  if (blen > 1) {
    char* compiler_log = new char[blen];
    GLsizei slen = 0;
    glGetShaderInfoLog(shaderObject, blen, &slen, compiler_log);
    std::cout << "compiler_log:\n" << compiler_log;
    delete compiler_log;
  }

  if (compiled && (blen == 0)) { //if compilation was successful and if there are no error or warning messages (error string length == 0)
    return true;
  }
  else {
    return false;
  }
}
/** @brief creates shader program
    @details creating the shader program consists of 5 steps:\n
    1. create Vertex shader and Fragment shader\n
    2. load shader sources\n
    3. compile shaders\n
    4. create a shader program that contains vertex and fragment shader
    5. link shader program
*/
void Shader::createShaderProgram()
{
  //Initialize Shaders
  GLuint vertexShaderObject, fragmentShaderObject;

  //1. create shaders
  vertexShaderObject = glCreateShader(GL_VERTEX_SHADER);
  fragmentShaderObject = glCreateShader(GL_FRAGMENT_SHADER);

  const char* vs = VertexShaderSource.c_str();
  const char* fs = FragmentShaderSource.c_str();

  //2. load shader source programs
  glShaderSource(vertexShaderObject, 1, &vs, 0);
  glShaderSource(fragmentShaderObject, 1, &fs, 0);

  //3.1. compile vertex shader program
  glCompileShader(vertexShaderObject);
  checkShaderCompilationStatus(vertexShaderObject);

  //3.2. compile fragment shader program
  glCompileShader(fragmentShaderObject);
  checkShaderCompilationStatus(fragmentShaderObject);

  //4. Create shader program and attach both shaders
  m_programID = glCreateProgram();

  glAttachShader(m_programID, vertexShaderObject);
  glAttachShader(m_programID, fragmentShaderObject);

  //5. link shader program
  glLinkProgram(m_programID);
}
